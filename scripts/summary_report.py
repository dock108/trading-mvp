#!/usr/bin/env python3
"""
Summary Report Generator for Trading MVP

This script generates comprehensive human-readable reports from trading simulation CSV files.
It analyzes trade history, portfolio allocations, and performance metrics.

USAGE:
    1. Run the main trading simulation first:
       $ python main.py --backtest
    
    2. After simulation completes, run this summary report:
       $ python summary_report.py
    
    3. Or specify custom CSV files:
       $ python summary_report.py -t trades.csv -d detailed_trades.csv

FEATURES:
    - Overall simulation statistics
    - Weekly trade breakdown  
    - Week-by-week allocation summary with contextual descriptions
    - Readable trade history with strategy mechanics
    - Strategy performance analysis
    - Capital allocation tracking
    - Detailed performance metrics with final returns
    - Backtest mode information

OUTPUT:
    The report shows:
    - How capital was allocated each week
    - Complete trade history in readable format
    - Final portfolio values and returns for each strategy
    - Strategy performance comparison
    
REQUIREMENTS:
    - trades.csv (generated by main.py)
    - detailed_trades.csv (optional, for enhanced information)
"""

import csv
import argparse
from datetime import datetime
from collections import defaultdict
import sys
import os

# Add parent directory to path to import modules
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.performance_metrics import PerformanceMetrics

def read_trades_csv(filename='trades.csv'):
    """Read trades from CSV file and return structured data.
    
    Args:
        filename (str): Path to trades CSV file
        
    Returns:
        list: List of trade dictionaries with proper type conversion
    """
    trades = []
    
    try:
        with open(filename, newline="") as f:
            reader = csv.reader(f)
            headers = next(reader)  # Read header row
            
            for row in reader:
                # Convert CSV row to structured trade data
                trade = {
                    'week': row[0],
                    'strategy': row[1], 
                    'asset': row[2],
                    'action': row[3],
                    'quantity': float(row[4]) if row[4] else 0.0,
                    'price': float(row[5]) if row[5] else 0.0,
                    'amount': float(row[6]) if row[6] else 0.0
                }
                trades.append(trade)
                
    except FileNotFoundError:
        print(f"Error: Could not find {filename}")
        print("Make sure to run the main trading simulation first to generate CSV files.")
        return []
    except Exception as e:
        print(f"Error reading {filename}: {e}")
        return []
    
    return trades

def read_detailed_trades_csv(filename='detailed_trades.csv'):
    """Read detailed trades with additional metadata.
    
    Args:
        filename (str): Path to detailed trades CSV file
        
    Returns:
        list: List of detailed trade dictionaries
    """
    trades = []
    
    try:
        with open(filename, newline="") as f:
            reader = csv.DictReader(f)
            for row in reader:
                # Convert numeric fields
                row['quantity'] = float(row['quantity']) if row['quantity'] else 0.0
                row['price'] = float(row['price']) if row['price'] else 0.0
                row['cash_flow'] = float(row['cash_flow']) if row['cash_flow'] else 0.0
                row['strike'] = float(row['strike']) if row['strike'] else None
                trades.append(row)
                
    except FileNotFoundError:
        print(f"Warning: Could not find {filename}")
        return []
    except Exception as e:
        print(f"Error reading {filename}: {e}")
        return []
    
    return trades

def generate_weekly_summary(trades):
    """Generate week-by-week summary of trading activity.
    
    Args:
        trades (list): List of trade dictionaries
        
    Returns:
        dict: Weekly summary data organized by week
    """
    weekly_data = defaultdict(lambda: {
        'trades': [],
        'wheel_activity': [],
        'rotator_activity': [],
        'total_cash_flow': 0.0,
        'wheel_cash_flow': 0.0,
        'rotator_cash_flow': 0.0
    })
    
    for trade in trades:
        week = trade['week']
        strategy = trade['strategy'].lower()
        
        # Add to weekly data
        weekly_data[week]['trades'].append(trade)
        weekly_data[week]['total_cash_flow'] += trade['amount']
        
        if strategy == 'wheel':
            weekly_data[week]['wheel_activity'].append(trade)
            weekly_data[week]['wheel_cash_flow'] += trade['amount']
        elif strategy == 'rotator':
            weekly_data[week]['rotator_activity'].append(trade)
            weekly_data[week]['rotator_cash_flow'] += trade['amount']
    
    return dict(weekly_data)

def print_header():
    """Print report header with timestamp."""
    print("=" * 80)
    print("TRADING MVP - SIMULATION SUMMARY REPORT")
    print("=" * 80)
    print(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()

def print_overall_statistics(trades):
    """Print overall simulation statistics.
    
    Args:
        trades (list): List of all trades
    """
    print("OVERALL SIMULATION STATISTICS")
    print("-" * 40)
    
    # Basic counts
    total_trades = len(trades)
    wheel_trades = len([t for t in trades if t['strategy'].lower() == 'wheel'])
    rotator_trades = len([t for t in trades if t['strategy'].lower() == 'rotator'])
    
    print(f"Total Trades: {total_trades}")
    print(f"  Wheel Strategy: {wheel_trades} trades")
    print(f"  Rotator Strategy: {rotator_trades} trades")
    
    # Cash flow analysis
    total_cash_flow = sum(t['amount'] for t in trades)
    wheel_cash_flow = sum(t['amount'] for t in trades if t['strategy'].lower() == 'wheel')
    rotator_cash_flow = sum(t['amount'] for t in trades if t['strategy'].lower() == 'rotator')
    
    print(f"\nNet Cash Flow:")
    print(f"  Combined: ${total_cash_flow:+,.2f}")
    print(f"  Wheel Strategy: ${wheel_cash_flow:+,.2f}")
    print(f"  Rotator Strategy: ${rotator_cash_flow:+,.2f}")
    
    # Week range
    weeks = sorted(set(t['week'] for t in trades))
    if weeks:
        print(f"\nSimulation Period: {weeks[0]} to {weeks[-1]} ({len(weeks)} weeks)")
    
    print()

def print_weekly_breakdown(weekly_data):
    """Print detailed week-by-week breakdown.
    
    Args:
        weekly_data (dict): Weekly summary data
    """
    print("WEEKLY BREAKDOWN")
    print("-" * 60)
    
    # Sort weeks for chronological order
    weeks = sorted(weekly_data.keys())
    
    for week in weeks:
        data = weekly_data[week]
        trade_count = len(data['trades'])
        
        print(f"\n{week.upper()}:")
        print(f"  Total Trades: {trade_count}")
        print(f"  Net Cash Flow: ${data['total_cash_flow']:+,.2f}")
        
        # Wheel strategy activity
        if data['wheel_activity']:
            print(f"  \nWheel Strategy ({len(data['wheel_activity'])} trades):")
            print(f"    Cash Flow: ${data['wheel_cash_flow']:+,.2f}")
            for trade in data['wheel_activity']:
                action_desc = trade['action'].replace('_', ' ').title()
                print(f"    • {action_desc} {trade['asset']}: {trade['quantity']} @ ${trade['price']:.2f} = ${trade['amount']:+,.2f}")
        
        # Rotator strategy activity  
        if data['rotator_activity']:
            print(f"  \nRotator Strategy ({len(data['rotator_activity'])} trades):")
            print(f"    Cash Flow: ${data['rotator_cash_flow']:+,.2f}")
            for trade in data['rotator_activity']:
                action_desc = trade['action'].replace('_', ' ').title()
                print(f"    • {action_desc} {trade['asset']}: {trade['quantity']:.4f} @ ${trade['price']:,.0f} = ${trade['amount']:+,.2f}")

def print_strategy_analysis(trades):
    """Print detailed strategy performance analysis.
    
    Args:
        trades (list): List of all trades
    """
    print("\n" + "=" * 60)
    print("STRATEGY PERFORMANCE ANALYSIS")
    print("=" * 60)
    
    # Separate trades by strategy
    wheel_trades = [t for t in trades if t['strategy'].lower() == 'wheel']
    rotator_trades = [t for t in trades if t['strategy'].lower() == 'rotator']
    
    # Wheel strategy analysis
    if wheel_trades:
        print("\nOPTIONS WHEEL STRATEGY:")
        print("-" * 30)
        
        wheel_cash_flow = sum(t['amount'] for t in wheel_trades)
        print(f"Total Trades: {len(wheel_trades)}")
        print(f"Net Cash Flow: ${wheel_cash_flow:+,.2f}")
        
        # Action breakdown
        actions = defaultdict(int)
        action_cash_flow = defaultdict(float)
        for trade in wheel_trades:
            actions[trade['action']] += 1
            action_cash_flow[trade['action']] += trade['amount']
        
        print(f"\nAction Breakdown:")
        for action in sorted(actions.keys()):
            action_name = action.replace('_', ' ').title()
            print(f"  {action_name}: {actions[action]} trades, ${action_cash_flow[action]:+,.2f}")
        
        # Asset breakdown
        assets = defaultdict(int)
        for trade in wheel_trades:
            assets[trade['asset']] += 1
        
        print(f"\nAsset Distribution:")
        for asset in sorted(assets.keys()):
            print(f"  {asset}: {assets[asset]} trades")
    
    # Rotator strategy analysis
    if rotator_trades:
        print("\nCRYPTO ROTATOR STRATEGY:")
        print("-" * 30)
        
        rotator_cash_flow = sum(t['amount'] for t in rotator_trades)
        print(f"Total Trades: {len(rotator_trades)}")
        print(f"Net Cash Flow: ${rotator_cash_flow:+,.2f}")
        
        # Action breakdown
        actions = defaultdict(int)
        action_cash_flow = defaultdict(float)
        for trade in rotator_trades:
            actions[trade['action']] += 1
            action_cash_flow[trade['action']] += trade['amount']
        
        print(f"\nAction Breakdown:")
        for action in sorted(actions.keys()):
            action_name = action.replace('_', ' ').title()
            print(f"  {action_name}: {actions[action]} trades, ${action_cash_flow[action]:+,.2f}")
        
        # Asset breakdown with average prices
        assets = defaultdict(list)
        for trade in rotator_trades:
            assets[trade['asset']].append(trade['price'])
        
        print(f"\nAsset Activity:")
        for asset in sorted(assets.keys()):
            prices = assets[asset]
            avg_price = sum(prices) / len(prices)
            print(f"  {asset}: {len(prices)} trades, avg price ${avg_price:,.0f}")

def compute_weekly_allocations(trades):
    """Compute portfolio allocations week by week by iterating chronologically.
    
    Args:
        trades (list): List of trade dictionaries
        
    Returns:
        dict: Weekly allocation data organized by week
    """
    # Get all unique weeks and sort them chronologically
    all_weeks = sorted(set(t['week'] for t in trades))
    
    # Initialize tracking variables
    wheel_current_asset = None      # None means cash, otherwise stock symbol
    wheel_holding_shares = 0        # Number of shares held
    rotator_current_coin = None     # None means cash, otherwise crypto symbol
    
    weekly_allocations = {}
    
    # Iterate through weeks chronologically
    for week in all_weeks:
        # Initialize week allocation (carry forward from previous week)
        wheel_allocation = "cash" if wheel_current_asset is None else wheel_current_asset
        rotator_allocation = rotator_current_coin
        
        # Get all trades for this week
        week_trades = [t for t in trades if t['week'] == week]
        
        # Process each trade in this week
        for trade in week_trades:
            strategy = trade['strategy'].lower()
            action = trade['action']
            asset = trade['asset']
            quantity = trade['quantity']
            
            if strategy == 'wheel':
                if action == 'BUY_SHARES':
                    # Wheel buys stock - allocation becomes that stock
                    wheel_current_asset = asset
                    wheel_holding_shares = int(quantity)
                    wheel_allocation = asset
                    
                elif action == 'SELL_SHARES':
                    # Wheel sells stock - allocation becomes cash
                    wheel_current_asset = None
                    wheel_holding_shares = 0
                    wheel_allocation = "cash"
                    
                # Note: PUT/CALL options don't change the underlying allocation
                
            elif strategy == 'rotator':
                if action == 'BUY_CRYPTO':
                    # Rotator buys crypto - allocation becomes that coin
                    rotator_current_coin = asset
                    rotator_allocation = asset
                    
                elif action == 'SELL_CRYPTO':
                    # Rotator sells - temporarily cash until next buy
                    # (usually followed by immediate buy in same week)
                    # Don't update rotator_current_coin yet - wait for potential buy
                    pass
        
        # After processing all trades for this week, record final allocations
        final_wheel = "cash" if wheel_current_asset is None else wheel_current_asset
        final_rotator = rotator_current_coin
        
        weekly_allocations[week] = {
            'wheel_allocation': final_wheel,
            'wheel_asset': wheel_current_asset,
            'wheel_shares': wheel_holding_shares,
            'rotator_allocation': final_rotator,
            'rotator_coin': rotator_current_coin
        }
    
    return weekly_allocations

def print_weekly_allocation_summary(trades):
    """Print week-by-week allocation summary with enhanced descriptions.
    
    Args:
        trades (list): List of all trades
    """
    print("\n" + "=" * 70)
    print("WEEKLY ALLOCATION SUMMARY")
    print("=" * 70)
    
    # Compute allocations using chronological iteration
    weekly_allocations = compute_weekly_allocations(trades)
    weekly_data = generate_weekly_summary(trades)
    
    for week in sorted(weekly_allocations.keys()):
        allocation = weekly_allocations[week]
        week_trades = weekly_data[week]['trades']
        
        # Get previous week allocation for comparison
        week_num = int(week.replace('Week', ''))
        prev_week = f'Week{week_num-1}' if week_num > 0 else None
        prev_allocation = weekly_allocations.get(prev_week) if prev_week else None
        
        # Format wheel description with context
        wheel_allocation = allocation['wheel_allocation']
        wheel_desc = format_wheel_description(week_trades, wheel_allocation, allocation['wheel_shares'], prev_allocation)
        
        # Format rotator description with context
        rotator_allocation = allocation['rotator_allocation']
        rotator_desc = format_rotator_description(week_trades, rotator_allocation, prev_allocation)
        
        week_num_display = week.replace('Week', 'Week ')
        print(f"{week_num_display}: Wheel – {wheel_desc}; Rotator – {rotator_desc}")

def format_wheel_description(week_trades, current_allocation, shares, prev_allocation):
    """Format wheel strategy description with context about what happened."""
    wheel_trades = [t for t in week_trades if t['strategy'].lower() == 'wheel']
    
    if current_allocation == 'cash':
        # Check if we sold shares this week
        sell_trades = [t for t in wheel_trades if t['action'] == 'SELL_SHARES']
        if sell_trades:
            asset = sell_trades[0]['asset']
            return f"Exited {asset} (sold via covered call, back to cash)"
        else:
            # Check if we're staying in cash or just didn't have positions
            if prev_allocation and prev_allocation.get('wheel_allocation') == 'cash':
                return "All cash (no positions)"
            else:
                return "All cash (no positions)"
    else:
        # We're holding shares - check if we bought this week
        buy_trades = [t for t in wheel_trades if t['action'] == 'BUY_SHARES']
        if buy_trades:
            return f"{shares} shares {current_allocation} (entered via put assignment)"
        else:
            # We're continuing to hold from previous week
            return f"{shares} shares {current_allocation}"

def format_rotator_description(week_trades, current_allocation, prev_allocation):
    """Format rotator strategy description with context about rotations."""
    rotator_trades = [t for t in week_trades if t['strategy'].lower() == 'rotator']
    
    if current_allocation is None:
        return "All cash"
    
    # Check if we rotated this week
    buy_trades = [t for t in rotator_trades if t['action'] == 'BUY_CRYPTO']
    sell_trades = [t for t in rotator_trades if t['action'] == 'SELL_CRYPTO']
    
    if buy_trades and sell_trades:
        # We rotated - sold one and bought another
        sold_asset = sell_trades[0]['asset']
        return f"Rotated to {current_allocation} (100% in {current_allocation})"
    elif buy_trades:
        # We bought without selling (first purchase)
        return f"100% in {current_allocation}"
    else:
        # We're holding from previous week
        prev_coin = prev_allocation.get('rotator_allocation') if prev_allocation else None
        if prev_coin == current_allocation:
            return f"100% in {current_allocation} (held)"
        else:
            return f"100% in {current_allocation}"

def print_trade_history_summary(trades):
    """Print readable trade history organized by week.
    
    Args:
        trades (list): List of all trades
    """
    print("\n" + "=" * 60)
    print("TRADE HISTORY SUMMARY")
    print("=" * 60)
    
    weekly_data = generate_weekly_summary(trades)
    
    for week in sorted(weekly_data.keys()):
        week_trades = weekly_data[week]['trades']
        if not week_trades:
            continue
            
        week_display = week.replace('Week', 'Week ')
        print(f"\n{week_display}:")
        
        # Group trades by strategy for cleaner display
        wheel_trades = [t for t in week_trades if t['strategy'].lower() == 'wheel']
        rotator_trades = [t for t in week_trades if t['strategy'].lower() == 'rotator']
        
        # Print wheel trades
        for trade in wheel_trades:
            trade_desc = format_trade_description(trade)
            print(f"  Wheel – {trade_desc}")
            
        # Print rotator trades
        for trade in rotator_trades:
            trade_desc = format_trade_description(trade)
            print(f"  Rotator – {trade_desc}")

def format_trade_description(trade):
    """Format a single trade into readable description."""
    action = trade['action']
    asset = trade['asset']
    quantity = trade['quantity']
    price = trade['price']
    amount = abs(trade['amount'])
    
    if action == 'SELL_PUT':
        return f"Sell Put 1x {asset} at strike ${price:.2f}, premium ${amount:.2f}"
    elif action == 'BUY_SHARES':
        return f"Buy {int(quantity)} shares {asset} at ${price:.2f} (put assignment)"
    elif action == 'SELL_CALL':
        return f"Sell Call 1x {asset} at strike ${price:.2f}, premium ${amount:.2f}"
    elif action == 'SELL_SHARES':
        return f"Sell {int(quantity)} shares {asset} at ${price:.2f} (call exercise)"
    elif action == 'BUY_CRYPTO':
        return f"Buy {quantity:.4f} {asset} at price ${price:,.0f}"
    elif action == 'SELL_CRYPTO':
        return f"Sell {quantity:.4f} {asset} at price ${price:,.0f}"
    else:
        return f"{action} {quantity} {asset} at ${price:.2f}"

def calculate_performance_metrics(trades):
    """Calculate detailed performance metrics for each strategy.
    
    Args:
        trades (list): List of all trades
        
    Returns:
        dict: Performance metrics for each strategy
    """
    # Separate trades by strategy
    wheel_trades = [t for t in trades if t['strategy'].lower() == 'wheel']
    rotator_trades = [t for t in trades if t['strategy'].lower() == 'rotator']
    
    # Get final allocations to determine what's currently held
    weekly_allocations = compute_weekly_allocations(trades)
    final_week = max(weekly_allocations.keys())
    final_allocation = weekly_allocations[final_week]
    
    # Determine initial capital allocation based on which strategies are active
    has_wheel = len(wheel_trades) > 0
    has_rotator = len(rotator_trades) > 0
    
    if has_wheel and has_rotator:
        wheel_initial_capital = 50000
        rotator_initial_capital = 50000
    elif has_wheel:
        wheel_initial_capital = 100000
        rotator_initial_capital = 0
    elif has_rotator:
        wheel_initial_capital = 0
        rotator_initial_capital = 100000
    else:
        wheel_initial_capital = 50000
        rotator_initial_capital = 50000
    
    # Calculate Wheel Strategy performance
    wheel_net_cash_flow = sum(t['amount'] for t in wheel_trades)
    
    # Wheel final capital = initial + net cash flows from all trades
    # (includes premiums from options + P/L from stock trades)
    wheel_final_capital = wheel_initial_capital + wheel_net_cash_flow
    if wheel_initial_capital > 0:
        wheel_return_pct = ((wheel_final_capital - wheel_initial_capital) / wheel_initial_capital) * 100
    else:
        wheel_return_pct = 0.0
    
    # Calculate Rotator Strategy performance
    
    # For rotator, we need to account for what's currently held
    if final_allocation['rotator_allocation']:
        # We're holding crypto - need to get final price
        final_coin = final_allocation['rotator_allocation']
        
        # Get the last price for the final coin from trades
        final_coin_trades = [t for t in rotator_trades if t['asset'] == final_coin]
        if final_coin_trades:
            # Get the most recent trade price for this coin
            latest_trade = max(final_coin_trades, key=lambda x: x['week'])
            final_price = latest_trade['price']
            
            # Calculate quantity held (should be tracked in allocation)
            # Find the last BUY trade for this coin to get quantity
            buy_trades = [t for t in final_coin_trades if t['action'] == 'BUY_CRYPTO']
            if buy_trades:
                latest_buy = max(buy_trades, key=lambda x: x['week'])
                final_quantity = latest_buy['quantity']
                rotator_final_value = final_quantity * final_price
            else:
                rotator_final_value = 0
        else:
            rotator_final_value = 0
    else:
        # All cash - sum up all net cash flows
        rotator_final_value = rotator_initial_capital + sum(t['amount'] for t in rotator_trades)
    
    if rotator_initial_capital > 0:
        rotator_return_pct = ((rotator_final_value - rotator_initial_capital) / rotator_initial_capital) * 100
    else:
        rotator_return_pct = 0.0
    
    return {
        'wheel': {
            'initial_capital': wheel_initial_capital,
            'final_capital': wheel_final_capital,
            'net_cash_flow': wheel_net_cash_flow,
            'return_pct': wheel_return_pct,
            'position': final_allocation['wheel_allocation'],
            'shares': final_allocation['wheel_shares']
        },
        'rotator': {
            'initial_capital': rotator_initial_capital,
            'final_value': rotator_final_value,
            'return_pct': rotator_return_pct,
            'position': final_allocation['rotator_allocation']
        }
    }

def simulate_portfolio_history(trades, strategy_name, initial_capital):
    """Simulate portfolio value history from trades.
    
    This is a simplified version that tracks cumulative cash flows.
    In a real implementation, we would track actual portfolio values including positions.
    
    Args:
        trades: List of all trades
        strategy_name: Name of strategy to filter for
        initial_capital: Starting capital
        
    Returns:
        List of portfolio values over time
    """
    portfolio_values = [initial_capital]
    current_value = initial_capital
    
    # Get trades for this strategy sorted by week
    strategy_trades = [t for t in trades if t['strategy'].lower() == strategy_name.lower()]
    
    # Group by week
    weeks = sorted(set(t['week'] for t in strategy_trades))
    
    for week in weeks:
        week_trades = [t for t in strategy_trades if t['week'] == week]
        week_cash_flow = sum(t['amount'] for t in week_trades)
        current_value += week_cash_flow
        portfolio_values.append(current_value)
    
    return portfolio_values


def print_performance_metrics(trades):
    """Print detailed performance metrics for each strategy.
    
    Args:
        trades (list): List of all trades
    """
    print("\n" + "=" * 70)
    print("PERFORMANCE METRICS")
    print("=" * 70)
    
    metrics = calculate_performance_metrics(trades)
    
    # Calculate advanced metrics if we have portfolio history
    # For now, we'll simulate portfolio history from trades
    perf_calc = PerformanceMetrics()
    
    # Extract portfolio values from trades (simplified)
    # In a real implementation, we'd track actual portfolio values over time
    wheel_portfolio_values = simulate_portfolio_history(trades, 'wheel', metrics['wheel']['initial_capital'])
    rotator_portfolio_values = simulate_portfolio_history(trades, 'rotator', metrics['rotator']['initial_capital'])
    
    # Calculate advanced metrics for each strategy
    wheel_metrics = perf_calc.calculate_all_metrics(wheel_portfolio_values, 
                                                  [t for t in trades if t['strategy'].lower() == 'wheel'])
    rotator_metrics = perf_calc.calculate_all_metrics(rotator_portfolio_values,
                                                    [t for t in trades if t['strategy'].lower() == 'rotator'])
    
    # Wheel Strategy Performance
    wheel = metrics['wheel']
    print(f"\nWHEEL STRATEGY PERFORMANCE:")
    print(f"  Initial Capital: ${wheel['initial_capital']:,}")
    print(f"  Final Capital: ${wheel['final_capital']:,.2f}")
    print(f"  Net Cash Flow: ${wheel['net_cash_flow']:+,.2f}")
    print(f"  Total Return: {wheel['return_pct']:+.2f}%")
    print(f"  Sharpe Ratio: {wheel_metrics['sharpe_ratio']:.3f}")
    print(f"  Max Drawdown: {wheel_metrics['max_drawdown']:.2f}%")
    print(f"  Volatility: {wheel_metrics['volatility']:.2f}%")
    print(f"  Win Rate: {wheel_metrics['win_rate']:.1f}%")
    
    if wheel['position'] != 'cash':
        print(f"  Current Position: {wheel['shares']} shares of {wheel['position']}")
        print(f"  (Note: Final capital includes net cash flows; stock position valued at cost basis)")
    else:
        print(f"  Current Position: All cash")
    
    # Rotator Strategy Performance
    rotator = metrics['rotator']
    print(f"\nROTATOR STRATEGY PERFORMANCE:")
    print(f"  Initial Capital: ${rotator['initial_capital']:,}")
    print(f"  Final Portfolio Value: ${rotator['final_value']:,.2f}")
    print(f"  Total Return: {rotator['return_pct']:+.2f}%")
    print(f"  Sharpe Ratio: {rotator_metrics['sharpe_ratio']:.3f}")
    print(f"  Max Drawdown: {rotator_metrics['max_drawdown']:.2f}%")
    print(f"  Volatility: {rotator_metrics['volatility']:.2f}%")
    print(f"  Win Rate: {rotator_metrics['win_rate']:.1f}%")
    
    if rotator['position']:
        print(f"  Current Position: 100% in {rotator['position']}")
    else:
        print(f"  Current Position: All cash")
    
    # Combined Performance
    total_initial = wheel['initial_capital'] + rotator['initial_capital']
    total_final = wheel['final_capital'] + rotator['final_value']
    combined_return = ((total_final - total_initial) / total_initial) * 100
    
    print(f"\nCOMBINED PORTFOLIO PERFORMANCE:")
    print(f"  Initial Total Capital: ${total_initial:,}")
    print(f"  Final Total Value: ${total_final:,.2f}")
    print(f"  Overall Return: {combined_return:+.2f}%")
    
    # Performance comparison
    print(f"\nSTRATEGY COMPARISON:")
    if wheel['return_pct'] > rotator['return_pct']:
        better_strategy = "Wheel"
        performance_diff = wheel['return_pct'] - rotator['return_pct']
    else:
        better_strategy = "Rotator"
        performance_diff = rotator['return_pct'] - wheel['return_pct']
    
    print(f"  Best Performing Strategy: {better_strategy}")
    print(f"  Performance Difference: {performance_diff:+.2f} percentage points")

def print_capital_allocation_summary(trades, detailed_trades=None):
    """Print summary of capital allocation over time.
    
    Args:
        trades (list): List of basic trades
        detailed_trades (list): List of detailed trades with notes
    """
    print("\n" + "=" * 60)
    print("CAPITAL ALLOCATION SUMMARY")
    print("=" * 60)
    
    # Determine actual allocation based on which strategies have trades
    wheel_trades = [t for t in trades if t['strategy'].lower() == 'wheel']
    rotator_trades = [t for t in trades if t['strategy'].lower() == 'rotator']
    
    has_wheel = len(wheel_trades) > 0
    has_rotator = len(rotator_trades) > 0
    
    print("\nInitial Setup:")
    print("  Total Capital: $100,000")
    
    if has_wheel and has_rotator:
        print("  Wheel Strategy: $50,000 (50%)")
        print("  Rotator Strategy: $50,000 (50%)")
    elif has_wheel:
        print("  Wheel Strategy: $100,000 (100%)")
        print("  Rotator Strategy: $0 (disabled)")
    elif has_rotator:
        print("  Wheel Strategy: $0 (disabled)")
        print("  Rotator Strategy: $100,000 (100%)")
    else:
        print("  No strategies executed")
    
    # Track running totals by strategy
    wheel_running_total = sum(t['amount'] for t in wheel_trades)
    rotator_running_total = sum(t['amount'] for t in rotator_trades)
    
    print(f"\nNet Cash Flows:")
    print(f"  Wheel Strategy: ${wheel_running_total:+,.2f}")
    print(f"  Rotator Strategy: ${rotator_running_total:+,.2f}")
    print(f"  Combined: ${wheel_running_total + rotator_running_total:+,.2f}")
    
    print(f"\nNote: See Performance Metrics section below for detailed final values and returns.")

def print_backtest_info():
    """Print information about backtest mode and data sources."""
    print("\n" + "=" * 60)
    print("BACKTEST MODE INFORMATION")
    print("=" * 60)
    
    print("\nData Source: Deterministic Mock Historical Data")
    print("  - Reproducible results for testing and validation")
    print("  - Controlled price movements for strategy verification")
    print("  - Not based on real historical market data")
    
    print("\nStrategy Execution:")
    print("  - Options Wheel: Mock SPY options prices and assignments")
    print("  - Crypto Rotator: Mock BTC/ETH/SOL price movements")
    print("  - Weekly rotation based on simulated performance")
    
    print("\nNote: In live mode, strategies would use real market data")
    print("      and execute actual trades through broker APIs.")

def generate_summary_report(trades_file="trades.csv", detailed_file="detailed_trades.csv", quiet=False):
    """Generate summary report from CSV files (can be called from main.py or standalone).
    
    Args:
        trades_file (str): Path to trades CSV file
        detailed_file (str): Path to detailed trades CSV file  
        quiet (bool): If True, suppress file loading messages
        
    Returns:
        bool: True if report generated successfully, False otherwise
    """
    # Read trade data
    if not quiet:
        print("Reading trade data...")
    
    trades = read_trades_csv(trades_file)
    detailed_trades = read_detailed_trades_csv(detailed_file)
    
    if not trades:
        if not quiet:
            print("No trade data found. Please run the main simulation first.")
        return False
    
    if not quiet:
        print(f"Loaded {len(trades)} trades from {trades_file}")
        if detailed_trades:
            print(f"Loaded {len(detailed_trades)} detailed trades from {detailed_file}")
    
    # Generate weekly summary
    weekly_data = generate_weekly_summary(trades)
    
    # Print comprehensive report
    print_header()
    print_overall_statistics(trades)
    print_weekly_breakdown(weekly_data)
    print_weekly_allocation_summary(trades)
    print_trade_history_summary(trades)
    print_strategy_analysis(trades)
    print_capital_allocation_summary(trades, detailed_trades)
    print_performance_metrics(trades)
    print_backtest_info()
    
    print("\n" + "=" * 80)
    print("REPORT COMPLETE")
    print("=" * 80)
    
    return True

def main():
    """Main entry point for standalone summary report generation."""
    parser = argparse.ArgumentParser(
        description="Generate comprehensive summary report from trading simulation CSV files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""Examples:
  python summary_report.py                    # Use default CSV files
  python summary_report.py -t my_trades.csv  # Use custom trades file
  python summary_report.py --help            # Show this help message
  
Workflow:
  1. Run trading simulation:     python main.py --backtest
  2. Generate summary report:    python summary_report.py
  
The summary report analyzes trade history and shows:
  - Weekly allocation changes with context
  - Readable trade history with strategy mechanics  
  - Performance metrics and final returns
  - Strategy comparison and analysis
        """
    )
    parser.add_argument("--trades-file", "-t", 
                       default="trades.csv",
                       help="Path to trades CSV file (default: trades.csv)")
    parser.add_argument("--detailed-file", "-d",
                       default="detailed_trades.csv", 
                       help="Path to detailed trades CSV file (default: detailed_trades.csv)")
    
    args = parser.parse_args()
    
    # Generate the report
    success = generate_summary_report(args.trades_file, args.detailed_file, quiet=False)
    
    if not success:
        print("\nTo generate CSV files, first run:")
        print("  python main.py --backtest")
        print("\nThen run this summary report again.")
        exit(1)

if __name__ == "__main__":
    main()